## Syntax

```
interface UserA {        // looks like class syntax
    name: string;
    age: number;
}

type UserB = {          // looks like object literal syntax
    name: string;
    age: number;
}

const user: UserA = {  // it does not matter UserA or UserB here
    name: 'Mike',
    age: 20,
}

// Functions

type SumA = (a: number, b: number) => number;

interface SumB {
    (a: number, b: number): number
}

const sum: SumA = (a,b) => a + b; // it doe snot matter SumA or SumB here
```

**В старых версиях TypeScript (до TS 2.7) нельзя было наследоваться интерфейсом от типа. Сейчас это возможно:**

```
type Person = {
    isSmart: boolean;
}

interface GreatPerson extends Person {
    isKind: boolean;
}

const person: GreatPerson = {
    isKind: true,
    isSmart: true,
}
```

**Часто `type` и `interface` взаимозаменяемы. Но с помощью type можно сделать `alias` (псевдоним) дяя примитива (для большей читамости кода).**
```
type UniqueId = string;
interface User {
    id: UniqueId;
    password: string;
}
```

**Для массива определение через `type` выглядит лаконичней:**
```
// for arrays 

type NamesA = string[];

interface NamesB {
    [key: number]: string;
}

const arr: NamesB = ['Masha', 'Sveta'];
```

**С помощью `interface` нельзя описать кортеж (tuple):**
```
type State = [number, (n: number) => void];
const s: State = [1, (s)=> {}]
```









